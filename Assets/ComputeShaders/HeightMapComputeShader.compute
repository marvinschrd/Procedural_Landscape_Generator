// // Each #kernel tells which function to compile; you can have many kernels
// #pragma kernel CSMain
//
// RWStructuredBuffer<float> finalMap;
// StructuredBuffer<float> computedNoiseMap;
// StructuredBuffer<float2> octavesOffsets;
//
// RWStructuredBuffer<int> minMax;
//
// //Parameters
// int mapSize;
// int octaves;
// int mapScale;
// float persistance;
// float lacunarity;
//
// bool isPerlinNoise;
// int noiseEffect;
//
// float frequency;
// float amplitude;
//
// float halfwidth = mapSize *0.5f;
// float halfheight = mapSize * 0.5f;
//
// //-------------------------------------------------------------------------------------------------------------
// // Noise Shader Library for Unity - https://github.com/keijiro/NoiseShader
// //
// // Original work (webgl-noise) Copyright (C) 2011 Ashima Arts.
// // Translation and modification was made by Keijiro Takahashi.
// //
// // The noise functions in this shader are based on the webgl-noise GLSL shader. For further details
// // of the original shader, please see the following description from the
// // original source code.
// //
//
// // Simplex Noise
// // Description : Array and textureless GLSL 2D simplex noise function.
// //      Author : Ian McEwan, Ashima Arts.
// //  Maintainer : ijm
// //     Lastmod : 20110822 (ijm)
// //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
// //               Distributed under the MIT License. See LICENSE file.
// //               https://github.com/ashima/webgl-noise
// //
//
// // Perlin Noise
// // GLSL textureless classic 2D noise "cnoise",
// // with an RSL-style periodic variant "pnoise".
// // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// // Version: 2011-08-22
// //
// // Many thanks to Ian McEwan of Ashima Arts for the
// // ideas for permutation and gradient selection.
// //
// // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// // Distributed under the MIT license. See LICENSE file.
// // https://github.com/ashima/webgl-noise
// //
//
// float wglnoise_mod289(float x)
// {
//     return x - floor(x / 289) * 289;
// }
//
// float3 wglnoise_permute(float3 x)
// {
//     return wglnoise_mod289((x * 34 + 1) * x);
// }
//
// float4 wglnoise_permute(float4 x)
// {
//     return wglnoise_mod289((x * 34 + 1) * x);
// }
//
// float2 wglnoise_fade(float2 t)
// {
//     return t * t * t * (t * (t * 6 - 15) + 10);
// }
//
// float2 wglnoise_mod(float2 x, float2 y)
// {
//     return x - y * floor(x / y);
// }
//
//
// float3 SimplexNoiseGrad(float2 v)
// {
//     const float C1 = (3 - sqrt(3)) / 6;
//     const float C2 = (sqrt(3) - 1) / 2;
//
//     // First corner
//     float2 i  = floor(v + dot(v, C2));
//     float2 x0 = v -   i + dot(i, C1);
//
//     // Other corners
//     float2 i1 = x0.x > x0.y ? float2(1, 0) : float2(0, 1);
//     float2 x1 = x0 + C1 - i1;
//     float2 x2 = x0 + C1 * 2 - 1;
//
//     // Permutations
//     i = wglnoise_mod289(i); // Avoid truncation effects in permutation
//     float3 p = wglnoise_permute(    i.y + float3(0, i1.y, 1));
//     p = wglnoise_permute(p + i.x + float3(0, i1.x, 1));
//
//     // Gradients: 41 points uniformly over a unit circle.
//     // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
//     float3 phi = p / 41 * 3.14159265359 * 2;
//     float2 g0 = float2(cos(phi.x), sin(phi.x));
//     float2 g1 = float2(cos(phi.y), sin(phi.y));
//     float2 g2 = float2(cos(phi.z), sin(phi.z));
//
//     // Compute noise and gradient at P
//     float3 m  = float3(dot(x0, x0), dot(x1, x1), dot(x2, x2));
//     float3 px = float3(dot(g0, x0), dot(g1, x1), dot(g2, x2));
//
//     m = max(0.5 - m, 0);
//     float3 m3 = m * m * m;
//     float3 m4 = m * m3;
//
//     float3 temp = -8 * m3 * px;
//     float2 grad = m4.x * g0 + temp.x * x0 +
//                   m4.y * g1 + temp.y * x1 +
//                   m4.z * g2 + temp.z * x2;
//
//     return 99.2 * float3(grad, dot(m4, px));
// }
//
// float SimplexNoise(float2 v)
// {
//     return SimplexNoiseGrad(v).z;
// }
//
// //TEST
// float3 taylorInvSqrt(float3 r)
// {
//     return 1.79284291400159 - 0.85373472095314 * r;
// }
// float snoise(float2 v)
// {
//     const float4 C = float4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0
//                              0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
//                             -0.577350269189626,  // -1.0 + 2.0 * C.x
//                              0.024390243902439); // 1.0 / 41.0
//     // First corner
//     float2 i  = floor(v + dot(v, C.yy));
//     float2 x0 = v -   i + dot(i, C.xx);
//
//     // Other corners
//     float2 i1;
//     i1.x = step(x0.y, x0.x);
//     i1.y = 1.0 - i1.x;
//
//     // x1 = x0 - i1  + 1.0 * C.xx;
//     // x2 = x0 - 1.0 + 2.0 * C.xx;
//     float2 x1 = x0 + C.xx - i1;
//     float2 x2 = x0 + C.zz;
//
//     // Permutations
//     i = wglnoise_mod289(i); // Avoid truncation effects in permutation
//     float3 p =
//       wglnoise_permute(wglnoise_permute(i.y + float3(0.0, i1.y, 1.0))
//                     + i.x + float3(0.0, i1.x, 1.0));
//
//     float3 m = max(0.5 - float3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);
//     m = m * m;
//     m = m * m;
//
//     // Gradients: 41 points uniformly over a line, mapped onto a diamond.
//     // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
//     float3 x = 2.0 * frac(p * C.www) - 1.0;
//     float3 h = abs(x) - 0.5;
//     float3 ox = floor(x + 0.5);
//     float3 a0 = x - ox;
//
//     // Normalise gradients implicitly by scaling m
//     m *= taylorInvSqrt(a0 * a0 + h * h);
//
//     // Compute final noise value at P
//     float3 g;
//     g.x = a0.x * x0.x + h.x * x0.y;
//     g.y = a0.y * x1.x + h.y * x1.y;
//     g.z = a0.z * x2.x + h.z * x2.y;
//     return (130.0 * dot(m, g)) * 0.5 + 0.5;
// }
//
//
//
// float ClassicNoise_impl(float2 pi0, float2 pf0, float2 pi1, float2 pf1)
// {
//     pi0 = wglnoise_mod289(pi0); // To avoid truncation effects in permutation
//     pi1 = wglnoise_mod289(pi1);
//
//     float4 ix = float2(pi0.x, pi1.x).xyxy;
//     float4 iy = float2(pi0.y, pi1.y).xxyy;
//     float4 fx = float2(pf0.x, pf1.x).xyxy;
//     float4 fy = float2(pf0.y, pf1.y).xxyy;
//
//     float4 i = wglnoise_permute(wglnoise_permute(ix) + iy);
//
//     float4 phi = i / 41 * 3.14159265359 * 2;
//     float2 g00 = float2(cos(phi.x), sin(phi.x));
//     float2 g10 = float2(cos(phi.y), sin(phi.y));
//     float2 g01 = float2(cos(phi.z), sin(phi.z));
//     float2 g11 = float2(cos(phi.w), sin(phi.w));
//
//     float n00 = dot(g00, float2(fx.x, fy.x));
//     float n10 = dot(g10, float2(fx.y, fy.y));
//     float n01 = dot(g01, float2(fx.z, fy.z));
//     float n11 = dot(g11, float2(fx.w, fy.w));
//
//     float2 fade_xy = wglnoise_fade(pf0);
//     float2 n_x = lerp(float2(n00, n01), float2(n10, n11), fade_xy.x);
//     float n_xy = lerp(n_x.x, n_x.y, fade_xy.y);
//     return 1.44 * n_xy;
// }
//
// // Classic Perlin noise
// float ClassicNoise(float2 p)
// {
//     float2 i = floor(p);
//     float2 f = frac(p);
//     return ClassicNoise_impl(i, f, i + 1, f - 1);
// }
//
// // Classic Perlin noise, periodic variant
// float PeriodicNoise(float2 p, float2 rep)
// {
//     float2 i0 = wglnoise_mod(floor(p), rep);
//     float2 i1 = wglnoise_mod(i0 + 1, rep);
//     float2 f = frac(p);
//     return ClassicNoise_impl(i0, f, i1, f - 1);
// }
// //----------------------------------------------------------------------------------------------
//
//
//
// // Only one threads as each cell of the map will be computed on parallel with no groups
// [numthreads(1,1,1)]
// void CSMain(uint3 id : SV_DispatchThreadID)
// {
//    //  int posX = id.x % mapSize;
//    //  int posy = id.x / mapSize;
//    //
//    //  int floatToIntMultiplier = 1000;
//    //
//    //  int scale = mapScale;
//    //  float sampleX = (posX - halfwidth) / scale;
//    //  float sampleY = (posy - halfheight) / scale;
//    //
//    // float2 mapPoint = float2(sampleX, sampleY);
//    //
//    //      float p = persistance;
//    //      float frequency = 1.0f;
//    //      float amplitude = 1.0f;
//    //      float height = 0.0f;
//    //  for(int i = 0; i < octaves; ++i)
//    //  {
//    //      float noiseValue;
//    //      float2 tempPoint = float2(mapPoint.x * frequency + octavesOffsets[i].x, mapPoint.y * frequency + octavesOffsets[i].y);
//    //      
//    //      //Check fot what type of noise has to be computed (only PerlinNoise or SimplexNoise
//    //      if(isPerlinNoise)
//    //      {
//    //         noiseValue = ClassicNoise(tempPoint);
//    //      }
//    //      else
//    //      {
//    //          noiseValue = SimplexNoise(tempPoint);
//    //      }
//    //
//    //      //Apply effect
//    //      switch (noiseEffect)
//    //      {
//    //      case 0 : // NOEFFECT
//    //          {
//    //              height += noiseValue * amplitude;
//    //          }
//    //          break;
//    //      case 1: // BILLOW EFFECT
//    //          {
//    //              float billow = abs(noiseValue) * amplitude;
//    //              height += billow;
//    //          }
//    //          break;
//    //      case 2: // RIDGED EFFECT
//    //          {
//    //              float ridged = abs(noiseValue) * amplitude;
//    //              ridged = 1.0f - ridged;
//    //              height += ridged;
//    //          }
//    //          break;
//    //          default:
//    //              {
//    //                  height += noiseValue * amplitude;
//    //              }
//    //          break;
//    //      }
//    //
//    //      height += noiseValue * amplitude;
//    //      amplitude *= p;
//    //      frequency *= lacunarity;
//    //      finalMap[id.x] += height;
//    //  }
//    //  int val = int(finalMap[id.x] * floatToIntMultiplier);
//    //  InterlockedMin(minMax[0],val);
//    //  InterlockedMax(minMax[1],val);
//
//
//     int x = id.x % mapSize;
//     int y = id.x / mapSize;
//
//     float scale = mapScale;
//     float weight = 1;
//     for (int i = 0; i < octaves; i ++) {
//         finalMap[id.x] += snoise(float2(x,y)/mapSize * scale + octavesOffsets[i]) * weight;
//         scale *= lacunarity;
//         weight *= persistance;
//     }
//     int val = int(finalMap[id.x] * 1000);
//     InterlockedMin(minMax[0],val);
//     InterlockedMax(minMax[1],val); 
// }


#pragma kernel CSMain

RWStructuredBuffer<float> heightMap;
RWStructuredBuffer<int> minMax;
StructuredBuffer<float2> offsets;
int floatToIntMultiplier;

int mapSize;
int octaves;
int noiseEffect;
float lacunarity;
float persistence;
float scaleFactor;

// Noise Shader Library for Unity - https://github.com/keijiro/NoiseShader
//
// Original work (webgl-noise) Copyright (C) 2011 Ashima Arts.
// Translation and modification was made by Keijiro Takahashi.
//
// This shader is based on the webgl-noise GLSL shader. For further details
// of the original shader, please see the following description from the
// original source code.
//

//
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//

float3 mod289(float3 x)
{
    return x - floor(x / 289.0) * 289.0;
}

float2 mod289(float2 x)
{
    return x - floor(x / 289.0) * 289.0;
}

float3 permute(float3 x)
{
    return mod289((x * 34.0 + 1.0) * x);
}

float3 taylorInvSqrt(float3 r)
{
    return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(float2 v)
{
    const float4 C = float4( 0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                             0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                            -0.577350269189626,  // -1.0 + 2.0 * C.x
                             0.024390243902439); // 1.0 / 41.0
    // First corner
    float2 i  = floor(v + dot(v, C.yy));
    float2 x0 = v -   i + dot(i, C.xx);

    // Other corners
    float2 i1;
    i1.x = step(x0.y, x0.x);
    i1.y = 1.0 - i1.x;

    // x1 = x0 - i1  + 1.0 * C.xx;
    // x2 = x0 - 1.0 + 2.0 * C.xx;
    float2 x1 = x0 + C.xx - i1;
    float2 x2 = x0 + C.zz;

    // Permutations
    i = mod289(i); // Avoid truncation effects in permutation
    float3 p =
      permute(permute(i.y + float3(0.0, i1.y, 1.0))
                    + i.x + float3(0.0, i1.x, 1.0));

    float3 m = max(0.5 - float3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);
    m = m * m;
    m = m * m;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
    float3 x = 2.0 * frac(p * C.www) - 1.0;
    float3 h = abs(x) - 0.5;
    float3 ox = floor(x + 0.5);
    float3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    m *= taylorInvSqrt(a0 * a0 + h * h);

    // Compute final noise value at P
    float3 g;
    g.x = a0.x * x0.x + h.x * x0.y;
    g.y = a0.y * x1.x + h.y * x1.y;
    g.z = a0.z * x2.x + h.z * x2.y;
    return (130.0 * dot(m, g)) * 0.5 + 0.5;
}


[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int x = id.x % mapSize;
    int y = id.x / mapSize;

    float halfSize = mapSize * 0.5f;

    float sampleX = (x - halfSize) / scaleFactor;
    float sampleY = (y - halfSize) / scaleFactor;

    float2 mapPoint = float2(sampleX, sampleY);
    
    float amplitude = 1;
    float frequency = 1;
    float height = 0;
    for (int i = 0; i < octaves; i ++) {
        float2 tempPoint = float2(mapPoint.x * frequency + offsets[i].x, mapPoint.y * frequency + offsets[i].y);
       // heightMap[id.x] += snoise(float2(x,y)/mapSize * scale + offsets[i]) * weight;
        float noiseValue = snoise(tempPoint);
        
        // float billow = abs(noiseValue) * amplitude;
        // height += billow;

        float absoluteValue = abs(noiseValue);
        float ridged = absoluteValue * amplitude;
        ridged = 1 - ridged;
        ridged *= ridged * ridged;
        height += ridged;

        //height += noiseValue * amplitude;
        
        frequency *= lacunarity;
        amplitude *= persistence;
    }
        heightMap[id.x] = height;
    int val = int(heightMap[id.x] * floatToIntMultiplier);
    InterlockedMin(minMax[0],val);
    InterlockedMax(minMax[1],val); 
}